<!DOCTYPE HTML><html lang="id"><head><meta charset="UTF-8"><meta content="text/html; charset=utf-8"http-equiv="Content-Type"><title>Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling - Devops Tutorial</title><meta content="IE=edge"http-equiv="X-UA-Compatible"/><meta http-equiv="content-language" content="id"/><script data-ad-client="ca-pub-1417781814120840" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: "ca-pub-1417781814120840", enable_page_level_ads: true }); </script><meta content="GitBook 3.2.3"name="generator"><link href="../gitbook/style.css"rel="stylesheet"><link href="../gitbook/gitbook-plugin-disqus/plugin.css"rel="stylesheet"><link href="../gitbook/gitbook-plugin-highlight/website.css"rel="stylesheet"><link href="../gitbook/gitbook-plugin-search/search.css"rel="stylesheet"><link href="../gitbook/gitbook-plugin-fontsettings/website.css"rel="stylesheet"><link href="style.css"rel="stylesheet"><meta content="UZnxS2Dk3fm2_Elms3a__56Q_oQ3sQ1h0SVXXlHSmbE"name="google-site-verification"><meta content="https://devops.novalagung.com/images/cover_fb_share.jpg"name="og:image"><meta content="https://devops.novalagung.com/images/cover_fb_share.jpg"name="twitter:image"><meta content="true"name="HandheldFriendly"/><meta content="width=device-width,initial-scale=1,user-scalable=no"name="viewport"><meta content="yes"name="apple-mobile-web-app-capable"><meta content="black"name="apple-mobile-web-app-status-bar-style"><link href="../gitbook/images/apple-touch-icon-precomposed-152.png"rel="apple-touch-icon-precomposed"sizes="152x152"><link href="../gitbook/images/favicon.ico"rel="shortcut icon"type="image/x-icon"><link href="terraform-aws-ec2-internet-gateway-ssh.html"rel="prev"/><script async defer src="https://buttons.github.io/buttons.js"></script></head><body><div class="book"><div class="book-summary"><div role="search"id="book-search-input"><input placeholder="Type to search"type="text"/></div><nav role="navigation"><ul class="summary"><li class="chapter"data-level="1.1"data-path="./"><a href="./">Introduction</a></li><li class="chapter"data-level="1.2"><span>Amazon Web Services (AWS)</span></li><li class="chapter"data-level="1.3"data-path="aws-membuat-user-iam.html"><a href="aws-membuat-user-iam.html">Membuat User IAM</a></li><li class="chapter"data-level="1.4"><span>Docker</span></li><li class="chapter"data-level="1.5"data-path="docker-push-image-ke-hub.html"><a href="docker-push-image-ke-hub.html">Push Image ke hub.docker.com</a></li><li class="chapter"data-level="1.6"><span>Kubernetes</span></li><li class="chapter"data-level="1.7"data-path="kubernetes-minikube-deployment-service-horizontal-autoscale.html"><a href="kubernetes-minikube-deployment-service-horizontal-autoscale.html">Kubernetes - Deploy Aplikasi ke Kluster Minikube menggunakan Deployment controller, Service, dan Horizontal Pod Autoscaler</a></li><li class="chapter"data-level="1.8"><span>Terraform</span></li><li class="chapter"data-level="1.9"data-path="terraform-aws-ec2-internet-gateway-ssh.html"><a href="terraform-aws-ec2-internet-gateway-ssh.html">Terraform - Otomatisasi setup AWS EC2, Internet Gateway, dan SSH</a></li><li class="chapter active"data-level="1.10"data-path="terraform-aws-load-balancer-auto-scaling.html"><a href="terraform-aws-load-balancer-auto-scaling.html">Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling</a></li><li><a href="https://www.gitbook.com"target="blank"class="gitbook-link">Published with GitBook</a></li></ul></nav></div><div class="book-body"><div class="body-inner"><div class="book-header"role="navigation"><h1><a href=".">Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling</a></h1></div><div class="page-wrapper"role="main"tabindex="-1"><div class="page-inner"><div id="book-search-results"><div class="search-noresults"><section class="markdown-section normal"><h1 id="terraform---otomatisasi-setup-ec2-application-load-balancer-dan-auto-scaling">Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling</h1><p>Pada tutorial kali ini, kita akan belajar implementasi Terraform untuk mengotomatisasi setup EC2 instance pada environment Auto Scaling dengan Application Load Balancer sebagai gateway aksesnya. Kita akan deploy sebuah aplikasi web sederhana pada setiap instance yang up.</p><p>Karena kita akan menggunakan fitur auto-scaling, maka proses deploy aplikasi harus dilakukan secara otomatis (tidak bisa deploy secara manual).</p><p>Aplikasi web yang kita akan pakai adalah aplikasi hello world sederhana yang siap pakai. Aplikasi tersebut ada di Github, nantinya kita akan clone.</p><hr><h3 id="1-kebutuhan">1. Kebutuhan</h3><h4 id="11-terraform-cli">1.1. Terraform CLI</h4><p>Pastikan Terraform CLI tool tersedia. Jika belum, maka install terlebih dahulu.</p><h4 id="12-user-iam-aws">1.2. User IAM AWS</h4><p>Siapkan satu buah user IAM baru dengan <em>programmatic access key</em> aktif dan akses penuh ke EC2 management. Kita akan gunakan <code>access_key</code> dan <code>secret_key</code>-nya pada tutorial ini. Bisa ikuti guide berikut untuk cara buat user IAM baru: <a href="aws-membuat-user-iam.html">Membuat User IAM</a>.</p><h4 id="13-command-ssh-keygen-dan-ssh">1.3. Command <code>ssh-keygen</code> dan <code>ssh</code></h4><p>Pastikan CLI tools <code>ssh-keygen</code> dan <code>ssh</code> tersedia.</p><hr><h3 id="2-persiapan">2. Persiapan</h3><p>Buat folder baru (dengan nama bebas), isinya satu buah file bernama <code>infrastructure.tf</code>. Kita akan gunakan file ini untuk pendefinisian kode infrastruktur. Semua kode setup resource akan dituliskan dalam bahasa HCL dalam file tersebut, meliputi:</p><ul><li>Upload key pair (untuk keperluan SSH akses dari lokal ke EC2 instance).</li><li>Subnetting pada dua availability zones berbeda (tapi masih dalam satu region).</li><li>Setup Application Load Balancer, listener-nya, security group, dan juga target group.</li><li>Setup Auto-scaling dan launch config-nya.</li></ul><p>Ok, mari kita mulai tutorialnya. Pertma siapkan folder dan file yang sudah disinggung di atas.</p><pre><code class="lang-bash">mkdir terraform-automate-aws-ec2-instance
<span class="hljs-built_in">cd</span> terraform-automate-aws-ec2-instance
touch infrastructure.tf
</code></pre><p>Selanjutnya, buat public-key cryptography menggunakan CLI tool <code>ssh-keygen</code>. Dengan ini akan di-generate sebuah file public key <code>id_rsa.pub</code> dan private key <code>id_rsa</code>. Nantinya kita akan upload key public key-nya ke AWS dan menggunakan private key-nya untuk mengakses EC2 instance via <code>ssh</code>.</p><pre><code class="lang-bash"><span class="hljs-built_in">cd</span> terraform-automate-aws-ec2-instance
ssh-keygen -t rsa <span class="hljs-_">-f</span> ./id_rsa
</code></pre><p><img alt="Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling - generate key pair"src="https://i.imgur.com/ZB16oJB.png"></p><hr><h3 id="3-kode-infrastruktur">3. Kode Infrastruktur</h3><p>Sekarang, mari kita mulai penulisan kode infrastruktur. Silakan buka file <code>infrastructure.tf</code> menggunakan editor apa saja bebas.</p><h4 id="31-set-aws-sebagai-provider">3.1. Set AWS sebagai provider</h4><p>Definisikan blok kode provider, disini kita akan gunakan <a href="https://www.terraform.io/docs/providers/aws/index.html"target="_blank">AWS sebagai cloud provider</a>. Dalam blok kode provider, tulis informasi akses AWS seperti <code>region</code>, <code>access_key</code>, dan <code>secret_key</code>. Untuk keys nilainya kita isi menggunakan keys dari user IAM yang sudah dibuat (jadi silakan sesuaikan value-nya).</p><p>Ok, berikut adalah blok kode provider, silakan tulis pada file <code>infrastructure.tf</code>.</p><pre><code class="lang-bash">provider <span class="hljs-string">&quot;aws&quot;</span> {
    region = <span class="hljs-string">&quot;ap-southeast-1&quot;</span>
    access_key = <span class="hljs-string">&quot;AKIAWLTS5CSXP7E3YLWG&quot;</span>
    secret_key = <span class="hljs-string">&quot;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&quot;</span>
}
</code></pre><h4 id="32-generate-key-pair-baru-lalu-upload-ke-aws">3.2. Generate key pair baru, lalu upload ke AWS</h4><p>Definisikan blok kode <a href="https://www.terraform.io/docs/providers/aws/r/key_pair.html"target="_blank">resource <code>aws_key_pair</code></a>, namai blok tersebut dengan <code>my_instance_key_pair</code>, lalu tambahkan file public key yang sebelumnya sudah di-generate <code>id_rsa.pub</code> ke dalam blok kode ini.</p><pre><code class="lang-bash">resource <span class="hljs-string">&quot;aws_key_pair&quot;</span> <span class="hljs-string">&quot;my_instance_key_pair&quot;</span> {
    key_name = <span class="hljs-string">&quot;terraform_learning_key_1&quot;</span>
    public_key = file(<span class="hljs-string">&quot;id_rsa.pub&quot;</span>)
}
</code></pre><h4 id="33-book-a-vpc-and-enable-internet-gateway-on-it">3.3. Book a VPC, and enable internet gateway on it</h4><p>Book a VPC, name it <code>my_vpc</code>. Then enable internet gateway on it. Each part of the code below is self-explanatory.</p><pre><code class="lang-bash"><span class="hljs-comment"># allocate a vpc named my_vpc.</span>
resource <span class="hljs-string">&quot;aws_vpc&quot;</span> <span class="hljs-string">&quot;my_vpc&quot;</span> {
    cidr_block = <span class="hljs-string">&quot;10.0.0.0/16&quot;</span>
    <span class="hljs-built_in">enable</span>_dns_hostnames = <span class="hljs-literal">true</span>
}

<span class="hljs-comment"># setup internet gateway for my_vpc.</span>
resource <span class="hljs-string">&quot;aws_internet_gateway&quot;</span> <span class="hljs-string">&quot;my_vpc_igw&quot;</span> {
    vpc_id = aws_vpc.my_vpc.id
}

<span class="hljs-comment"># attach the internet gateway my_vpc_igw into my_vpc.</span>
resource <span class="hljs-string">&quot;aws_route_table&quot;</span> <span class="hljs-string">&quot;my_public_route_table&quot;</span> {
    vpc_id = aws_vpc.my_vpc.id
    route {
        cidr_block = <span class="hljs-string">&quot;0.0.0.0/0&quot;</span>
        gateway_id = aws_internet_gateway.my_vpc_igw.id
    }
}
</code></pre><h4 id="34-allocate-two-different-subnets-on-two-different-availability-zones-within-the-same-region">3.4. Allocate two different subnets on two different availability zones (within the same region)</h4><p>Application Load Balancer or ALB requires two subnets setup on two availability zones (within the same region).</p><p>In this example, the region we used is <code>ap-southeast-1</code>, as defined in the provider block above (see 3.1). There are two zones available within this region, <code>ap-southeast-1a</code> and <code>ap-southeast-1b</code>. The ALB (not classic network load balancer) requires at least to be enabled on two different zones, so we will use those two.</p><pre><code class="lang-bash"><span class="hljs-comment"># prepare a subnet for availability zone ap-southeast-1a.</span>
resource <span class="hljs-string">&quot;aws_subnet&quot;</span> <span class="hljs-string">&quot;my_subnet_public_southeast_1a&quot;</span> {
    vpc_id = aws_vpc.my_vpc.id
    cidr_block = <span class="hljs-string">&quot;10.0.0.0/24&quot;</span>
    availability_zone = <span class="hljs-string">&quot;ap-southeast-1a&quot;</span>
}
<span class="hljs-comment"># associate the internet gateway into newly created subnet for ap-southeast-1a</span>
resource <span class="hljs-string">&quot;aws_route_table_association&quot;</span> <span class="hljs-string">&quot;my_public_route_association_for_southeast_1a&quot;</span> {
    subnet_id = aws_subnet.my_subnet_public_southeast_1a.id
    route_table_id = aws_route_table.my_public_route_table.id
}

<span class="hljs-comment"># prepare a subnet for availability zone ap-southeast-1b</span>
resource <span class="hljs-string">&quot;aws_subnet&quot;</span> <span class="hljs-string">&quot;my_subnet_public_southeast_1b&quot;</span> {
    vpc_id = aws_vpc.my_vpc.id
    cidr_block = <span class="hljs-string">&quot;10.0.1.0/24&quot;</span>
    availability_zone = <span class="hljs-string">&quot;ap-southeast-1b&quot;</span>
}
<span class="hljs-comment"># associate the internet gateway into newly created subnet for ap-southeast-1b</span>
resource <span class="hljs-string">&quot;aws_route_table_association&quot;</span> <span class="hljs-string">&quot;my_public_route_association_for_southeast_1b&quot;</span> {
    subnet_id = aws_subnet.my_subnet_public_southeast_1b.id
    route_table_id = aws_route_table.my_public_route_table.id
}
</code></pre><p>The internet gateway associated with two zones that we just created. In this example, it is required for the application hosted within instances on these zones to be able to connect to the internet.</p><h4 id="35-define-alb-resource-block-listener-security-group-and-target-group">3.5. Define ALB resource block, listener, security group, and target group</h4><p>The ALB will be created with two subnets attached (subnets from <code>ap-southeast-1a</code> and <code>ap-southeast-1b</code>).</p><pre><code class="lang-bash"><span class="hljs-comment"># create an Application Load Balancer.</span>
<span class="hljs-comment"># attach the previous availability zones&apos; subnets into this load balancer.</span>
resource <span class="hljs-string">&quot;aws_lb&quot;</span> <span class="hljs-string">&quot;my_alb&quot;</span> {
    name = <span class="hljs-string">&quot;my-alb&quot;</span>
    internal = <span class="hljs-literal">false</span> <span class="hljs-comment"># set lb for public access</span>
    load_balancer_<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;application&quot;</span> <span class="hljs-comment"># use Application Load Balancer</span>
    security_groups = [aws_security_group.my_alb_security_group.id]
    subnets = [ <span class="hljs-comment"># attach the availability zones&apos; subnets.</span>
        aws_subnet.my_subnet_public_southeast_1a.id,
        aws_subnet.my_subnet_public_southeast_1b.id 
    ]
}
</code></pre><p>The security group for our load balancer has only two rules.</p><ul><li>Allow only incoming TCP/HTTP request on port <code>80</code>.</li><li>Allow every kind of outgoing request.</li></ul><pre><code class="lang-bash"><span class="hljs-comment"># prepare a security group for our load balancer my_alb.</span>
resource <span class="hljs-string">&quot;aws_security_group&quot;</span> <span class="hljs-string">&quot;my_alb_security_group&quot;</span> {
    vpc_id = aws_vpc.my_vpc.id
    ingress {
        from_port = 80
        to_port = 80
        protocol = <span class="hljs-string">&quot;tcp&quot;</span>
        cidr_blocks = [<span class="hljs-string">&quot;0.0.0.0/0&quot;</span>]
    }
    egress {
        from_port = 0
        to_port = 0
        protocol = <span class="hljs-string">&quot;-1&quot;</span>
        cidr_blocks = [<span class="hljs-string">&quot;0.0.0.0/0&quot;</span>]
    }
}
</code></pre><p>Next, we shall prepare the ALB listener. The load balancer will listen for every incoming request to port <code>80</code>, and then the particular request will be directed towards port <code>8080</code> on the instance.</p><p>Port <code>8080</code> is chosen here because the application (that will be deployed later) will listen to this port.</p><pre><code class="lang-bash"><span class="hljs-comment"># create an alb listener for my_alb.</span>
<span class="hljs-comment"># forward rule: only accept incoming HTTP request on port 80,</span>
<span class="hljs-comment"># then it&apos;ll be forwarded to port target:8080.</span>
resource <span class="hljs-string">&quot;aws_lb_listener&quot;</span> <span class="hljs-string">&quot;my_alb_listener&quot;</span> {  
    load_balancer_arn = aws_lb.my_alb.arn
    port = 80  
    protocol = <span class="hljs-string">&quot;HTTP&quot;</span>
    default_action {    
        target_group_arn = aws_lb_target_group.my_alb_target_group.arn
        <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;forward&quot;</span>  
    }
}

<span class="hljs-comment"># my_alb will forward the request to a particular app,</span>
<span class="hljs-comment"># that listen on 8080 within instances on my_vpc.</span>
resource <span class="hljs-string">&quot;aws_lb_target_group&quot;</span> <span class="hljs-string">&quot;my_alb_target_group&quot;</span> {
    port = 8080
    protocol = <span class="hljs-string">&quot;HTTP&quot;</span>
    vpc_id = aws_vpc.my_vpc.id
}
</code></pre><h4 id="36-define-launch-config-and-its-required-dependencies-for-auto-scaling">3.6. Define launch config (and it&apos;s required dependencies) for auto-scaling</h4><p>We are not going to simply create an instance then deploy the application into it. Instead, the instance creation and app deployment will be automated using AWS auto-scaling feature.</p><p>In the resource block below, we will set up the launch configuration for the auto-scaling. This launch config is the one that decides how the instance will be created.</p><ul><li>The <em>Amazon Linux 2 AMI t2.micro</em> is used here.</li><li>The launched instance will have a public IP attached, this is better to be set to <code>false</code>, but in here we might need it for testing purposes.</li><li>The previously allocated key pair will also be used on the instance, to make it accessible through SSH access. This part is also for testing purposes.</li></ul><p>Other than that, there is one point left that is very important, the <code>user_data</code>. The user data is a block of bash script that will be executed during instance bootstrap. We will use this to automate the deployment of our application. The whole script is stored in a file named <code>deployment.sh</code>, we will prepare it later.</p><pre><code class="lang-bash"><span class="hljs-comment"># setup launch configuration for the auto-scaling.</span>
resource <span class="hljs-string">&quot;aws_launch_configuration&quot;</span> <span class="hljs-string">&quot;my_launch_configuration&quot;</span> {

    <span class="hljs-comment"># Amazon Linux 2 AMI (HVM), SSD Volume Type (ami-0f02b24005e4aec36).</span>
    image_id = <span class="hljs-string">&quot;ami-0f02b24005e4aec36&quot;</span>

    instance_<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;t2.micro&quot;</span>
    key_name = aws_key_pair.my_instance_key_pair.key_name <span class="hljs-comment"># terraform_learning_key_2</span>
    security_groups = [aws_security_group.my_launch_config_security_group.id]

    <span class="hljs-comment"># set to false on prod stage.</span>
    <span class="hljs-comment"># otherwise true, because ssh access might be needed to the instance.</span>
    associate_public_ip_address = <span class="hljs-literal">true</span>
    lifecycle {
        <span class="hljs-comment"># ensure the new instance is only created before the other one is destroyed.</span>
        create_before_destroy = <span class="hljs-literal">true</span>
    }

    <span class="hljs-comment"># execute bash scripts inside deployment.sh on instance&apos;s bootstrap.</span>
    <span class="hljs-comment"># what the bash scripts going to do in summary:</span>
    <span class="hljs-comment"># fetch a hello world app from Github repo, then deploy it in the instance.</span>
    user_data = file(<span class="hljs-string">&quot;deployment.sh&quot;</span>)
}
</code></pre><p>Below is the launch config security group. In this block, we define the security group specifically for the instances that will be created by the auto scale launch config. Three rules defined here:</p><ul><li>Allow incoming <code>TCP/SSH</code> access on port <code>22</code>.</li><li>Allow <code>TCP/HTTP</code> access on port <code>8080</code>.</li><li>Allow every kind of outgoing requests.</li></ul><pre><code class="lang-bash"><span class="hljs-comment"># security group for launch config my_launch_configuration.</span>
resource <span class="hljs-string">&quot;aws_security_group&quot;</span> <span class="hljs-string">&quot;my_launch_config_security_group&quot;</span> {
    vpc_id = aws_vpc.my_vpc.id
    ingress {
        from_port = 22
        to_port = 22
        protocol = <span class="hljs-string">&quot;tcp&quot;</span>
        cidr_blocks = [<span class="hljs-string">&quot;0.0.0.0/0&quot;</span>]
    }
    ingress {
        from_port = 8080
        to_port = 8080
        protocol = <span class="hljs-string">&quot;tcp&quot;</span>
        cidr_blocks = [<span class="hljs-string">&quot;0.0.0.0/0&quot;</span>]
    }
    egress {
        from_port = 0
        to_port = 0
        protocol = <span class="hljs-string">&quot;-1&quot;</span>
        cidr_blocks = [<span class="hljs-string">&quot;0.0.0.0/0&quot;</span>]
    }
}
</code></pre><p>Ok, the autoscale launch config is ready, now we shall attach it into our ALB.</p><pre><code class="lang-bash"><span class="hljs-comment"># create an autoscaling then attach it into my_alb_target_group.</span>
resource <span class="hljs-string">&quot;aws_autoscaling_attachment&quot;</span> <span class="hljs-string">&quot;my_aws_autoscaling_attachment&quot;</span> {
    alb_target_group_arn = aws_lb_target_group.my_alb_target_group.arn
    autoscaling_group_name = aws_autoscaling_group.my_autoscaling_group.id
}
</code></pre><p>Next, we shall prepare the auto-scaling group config. This resource is used to determine when or on what condition the scaling process run.</p><ul><li>As per the below config, the auto-scaling will have a minimum of 2 instances alive, and 5 max.</li><li>The <code>ELB</code> health check is enabled.</li><li>The previous two subnets on <code>ap-southeast-1a</code> and <code>ap-southeast-1b</code> are applied.</li></ul><pre><code class="lang-bash"><span class="hljs-comment"># define the autoscaling group.</span>
<span class="hljs-comment"># attach my_launch_configuration into this newly created autoscaling group below.</span>
resource <span class="hljs-string">&quot;aws_autoscaling_group&quot;</span> <span class="hljs-string">&quot;my_autoscaling_group&quot;</span> {
    name = <span class="hljs-string">&quot;my-autoscaling-group&quot;</span>
    desired_capacity = 2 <span class="hljs-comment"># ideal number of instance alive</span>
    min_size = 2 <span class="hljs-comment"># min number of instance alive</span>
    max_size = 5 <span class="hljs-comment"># max number of instance alive</span>
    health_check_<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;ELB&quot;</span>

    <span class="hljs-comment"># allows deleting the autoscaling group without waiting</span>
    <span class="hljs-comment"># for all instances in the pool to terminate</span>
    force_delete = <span class="hljs-literal">true</span>

    launch_configuration = aws_launch_configuration.my_launch_configuration.id
    vpc_zone_identifier = [
        aws_subnet.my_subnet_public_southeast_1a.id,
        aws_subnet.my_subnet_public_southeast_1b.id 
    ]
    timeouts {
        delete = <span class="hljs-string">&quot;15m&quot;</span> <span class="hljs-comment"># timeout duration for instances</span>
    }
    lifecycle {
        <span class="hljs-comment"># ensure the new instance is only created before the other one is destroyed.</span>
        create_before_destroy = <span class="hljs-literal">true</span>
    }
}
</code></pre><h4 id="37-print-the-alb-public-dns">3.7. Print the ALB public DNS</h4><p>Everything is pretty much done, except we need to print the ALB public DNS, so then we can do the testing.</p><pre><code class="lang-bash"><span class="hljs-comment"># print load balancer&apos;s DNS, test it using curl.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># curl my-alb-625362998.ap-southeast-1.elb.amazonaws.com</span>
output <span class="hljs-string">&quot;alb-url&quot;</span> {
    value = aws_lb.my_alb.dns_name
}
</code></pre><hr><h3 id="4-app-deployment-script">4. App Deployment Script</h3><p>We have done with the infrastructure code, next prepare the deployment script.</p><p>Create a file named <code>deployment.sh</code> in the same directory where the infra code is placed. It will contain bash scripts for automating app deployment. This file will be used by auto-scaling launcher to automate app setup during instance bootstrap.</p><p>The application is written in Go, and the AMI <em>Amazon Linux 2 AMI t2.micro</em> that used here does not have any Go tools ready, that&apos;s why we need to set it up.</p><blockquote><p><strong>Deploying app</strong> means that the app is ready (has been built into binary), so what we need is simply just run the binary.</p><p>However to make our learning process better, in this example, we are going to fetch the app source code and perform the build and deploy processes within the instance.</p></blockquote><p>Ok, here we go, the bash script.</p><pre><code class="lang-bash"><span class="hljs-meta">#!/bin/bash
</span>
<span class="hljs-comment"># install git</span>
sudo yum -y install git

<span class="hljs-comment"># download go, then install it</span>
wget https://dl.google.com/go/go1.14.linux-amd64.tar.gz
sudo tar -C /usr/<span class="hljs-built_in">local</span> -xzf go1.14.linux-amd64.tar.gz

<span class="hljs-comment"># clone the hello world app.</span>
<span class="hljs-comment"># The app is hosted on private repo,</span>
<span class="hljs-comment"># that&apos;s why the github token is used on cloning the repo</span>
github_token=30542dd8874ba3745c55203a091c345340c18b7a
git <span class="hljs-built_in">clone</span> https://<span class="hljs-variable">$github_token</span>:x-oauth-basic@github.com/novalagung/hello-world.git \
    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cloned&quot;</span> \
    || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;clone failed&quot;</span>

<span class="hljs-comment"># export certain variables required by go</span>
<span class="hljs-built_in">export</span> GO111MODULE=on
<span class="hljs-built_in">export</span> GOROOT=/usr/<span class="hljs-built_in">local</span>/go
<span class="hljs-built_in">export</span> GOCACHE=~/gocache
mkdir -p <span class="hljs-variable">$GOCACHE</span>
<span class="hljs-built_in">export</span> GOPATH=~/goapp
mkdir -p <span class="hljs-variable">$GOPATH</span>

<span class="hljs-comment"># create local vars specifically for the app</span>
<span class="hljs-built_in">export</span> PORT=8080
<span class="hljs-built_in">export</span> INSTANCE_ID=`curl <span class="hljs-_">-s</span> http://169.254.169.254/latest/meta-data/instance-id`

<span class="hljs-comment"># build the app</span>
<span class="hljs-built_in">cd</span> hello-world
/usr/<span class="hljs-built_in">local</span>/go/bin/go env
/usr/<span class="hljs-built_in">local</span>/go/bin/go mod tidy
/usr/<span class="hljs-built_in">local</span>/go/bin/go build -o binary

<span class="hljs-comment"># run the app with nohup</span>
nohup ./binary &amp;
</code></pre><hr><h3 id="5-run-terraform">5. Run Terraform</h3><h4 id="51-terraform-initialization">5.1. Terraform initialization</h4><p>First, run the <code>terraform init</code> command. This command will do some setup/initialization, certain dependencies (like AWS provider that we used) will be downloaded.</p><pre><code class="lang-bash"><span class="hljs-built_in">cd</span> terraform-automate-aws-ec2-instance
terraform init
</code></pre><h4 id="52-terraform-plan">5.2. Terraform plan</h4><p>Next, run <code>terraform plan</code>, to see the plan of our infrastructure. This step is optional, however, might be useful for us to see the outcome from the infra file.</p><h4 id="53-terraform-apply">5.3. Terraform apply</h4><p>Last, run the <code>terraform apply</code> command to execute the infrastructure plan.</p><pre><code class="lang-bash"><span class="hljs-built_in">cd</span> terraform-automate-aws-ec2-instance
terraform apply -auto-approve
</code></pre><p>The <code>-auto-approve</code> flag is optional, it will skip the confirmation prompt during execution.</p><p>After the process is done, public DNS shall appear. Next, we shall test the instance.</p><hr><h3 id="6-test-instance">6. Test Instance</h3><p>Use the <code>curl</code> command to make an HTTP request to the ALB public DNS instance.</p><pre><code class="lang-bash">curl -X GET my-alb-613171058.ap-southeast-1.elb.amazonaws.com
</code></pre><p><img alt="Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling - curl to load balancer"src="https://i.imgur.com/5jonEG2.png"></p><p>We can see from the image above, the HTTP response is different from one another across those multiple <code>curl</code> commands. The load balancer manages the traffic, sometimes we will get the instance A, B, etc.</p><p>In the AWS console, the instances that up and running are visible.</p><p><img alt="Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling - aws console"src="https://i.imgur.com/iETYwfw.png"></p></section></div><div class="search-results"><div class="has-results"><h1 class="search-results-title">results matching ""</h1></div><div class="no-results"><h1 class="search-results-title">No results matching ""</h1></div></div></div></div></div></div></div><script>var gitbook=gitbook||[];gitbook.push(function(){gitbook.page.hasChanged({page:{title:"Terraform - Otomatisasi setup EC2, Application Load Balancer, dan Auto Scaling",level:"1.10",depth:1,previous:{title:"Terraform - Otomatisasi setup AWS EC2, Internet Gateway, dan SSH",level:"1.9",depth:1,path:"terraform-aws-ec2-internet-gateway-ssh.md",ref:"terraform-aws-ec2-internet-gateway-ssh.md",articles:[]},dir:"ltr"},config:{plugins:["ga","html-minifier","disqus","meta","scripts"],styles:{website:"style.css"},pluginsConfig:{disqus:{useIdentifier:!1,shortName:"devops-novalagung-com"},meta:{content:"",data:[{name:"google-site-verification",content:"UZnxS2Dk3fm2_Elms3a__56Q_oQ3sQ1h0SVXXlHSmbE"},{name:"og:image",content:"https://devops.novalagung.com/images/cover_fb_share.jpg"},{name:"twitter:image",content:"https://devops.novalagung.com/images/cover_fb_share.jpg"}],name:""},scripts:{files:[]},search:{},"html-minifier":{customAttrSurround:[],removeScriptTypeAttributes:!1,removeEmptyAttributes:!1,removeRedundantAttributes:!1,removeEmptyElements:!0,sortClassName:!0,caseSensitive:!0,html5:!0,collapseWhitespace:!0,processConditionalComments:!1,quoteCharacter:null,keepClosingSlash:!0,preventAttributesEscaping:!1,minifyURLs:!1,removeAttributeQuotes:!1,decodeEntities:!1,trimCustomFragments:!1,customAttrAssign:[],includeAutoGeneratedTags:!0,collapseInlineTagWhitespace:!1,collapseBooleanAttributes:!0,minifyJS:!0,removeTagWhitespace:!0,preserveLineBreaks:!1,sortAttributes:!0,removeStyleLinkTypeAttributes:!1,removeComments:!0,minifyCSS:!0,processScripts:[],conservativeCollapse:!1,removeOptionalTags:!1,useShortDoctype:!1},lunr:{maxIndexSize:1e6,ignoreSpecialCharacters:!1},fontsettings:{theme:"white",family:"sans",size:2},highlight:{},ga:{configuration:"auto",token:"UA-27602984-32"},sharing:{facebook:!0,twitter:!0,google:!1,weibo:!1,instapaper:!1,vk:!1,all:["facebook","google","twitter","weibo","instapaper"]},"theme-default":{styles:{website:"styles/website.css",pdf:"styles/pdf.css",epub:"styles/epub.css",mobi:"styles/mobi.css",ebook:"styles/ebook.css",print:"styles/print.css"},showLevel:!1}},theme:"default",lunr:{maxIndexSize:1e9},pdf:{pageNumbers:!0,fontSize:12,fontFamily:"Arial",paperSize:"a4",chapterMark:"pagebreak",pageBreaksBefore:"/",margin:{right:62,left:62,top:56,bottom:56}},structure:{langs:"LANGS.md",readme:"README.md",glossary:"GLOSSARY.md",summary:"SUMMARY.md"},variables:{},language:"id",gitbook:"*"},file:{path:"terraform-aws-load-balancer-auto-scaling.md",mtime:"2020-03-24T06:25:48.178Z",type:"markdown"},gitbook:{version:"3.2.3",time:"2020-03-24T06:26:51.195Z"},basePath:".",book:{language:"id"}})})</script></div><script src="../gitbook/gitbook.js"></script><script src="../gitbook/theme.js"></script><script src="../gitbook/gitbook-plugin-ga/plugin.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script><script src="../gitbook/gitbook-plugin-disqus/plugin.js"></script><script src="../gitbook/gitbook-plugin-search/search-engine.js"></script><script src="../gitbook/gitbook-plugin-search/search.js"></script><script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script><script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script><script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script><script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script><div style="position: fixed; top: 10px; right: 30px; padding: 10px; background-color: rgba(255, 255, 255, 0.7);"><a class="github-button" href="https://github.com/novalagung" data-size="large" aria-label="Follow @novalagung on GitHub">Follow @novalagung</a><script async defer src="https://buttons.github.io/buttons.js"></script></div></body></html>